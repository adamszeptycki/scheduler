#!/usr/bin/env python3

"Schedule a bunch of desired meetings."

from apiclient.discovery import build
from credentials import creds
from datetime import datetime, time, timedelta, timezone
from httplib2 import Http
from re import compile, split

import arrow

debug = False

class Interval():

    "Represent a time interval as start (inclusive) and end (exlcusive)."

    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __eq__(self, other):
        return self.start == other.start and self.end == other.end

    def __hash__(self):
        return hash((self.start, self.end))

    def __repr__(self):
        return '{} to {}'.format(self.start.isoformat(), self.end.isoformat())

    def before(self, other):
        return self.end <= other.start

    def after(self, other):
        return self.start >= other.end

    def from_calendar(cal):
        return Interval(arrow.get(cal['start']), arrow.get(cal['end']))


def busy(emails, start_day, start_time, end_time, days):
    "Map of intervals each person is busy according to their calendar."

    service = build('calendar', 'v3', http=creds.authorize(Http()))

    data = service.freebusy().query(body = {
        'timeMin': datetime.combine(start_day, start_time).isoformat(),
        'timeMax': datetime.combine(start_day + timedelta(days=days), end_time).isoformat(),
        'items': [ { 'id': e } for e in emails ],
        'timeZone': '-07:00'
    }).execute()

    return { name : to_intervals(x['busy']) for name, x in data['calendars'].items() }


def to_intervals(busy):
    return [ Interval.from_calendar(x) for x in busy ]


def busy_slots(slots, busy):
    "Pick intervals in slots that do not overlap any of the busy intervals."

    def walk(slots, busy):
        while slots and busy:
            s = slots[0]
            b = busy[0]
            if s.before(b):
                slots.pop(0)
            elif s.after(b):
                busy.pop(0)
            else:
                yield slots.pop(0)

    return list(walk(slots[:], busy[:]))


def slots(start_day, start_time, end_time, days=1, daysofweek={0,1,2,3,4}):
    """Get all slots during working hours starting on `start_day` and
extending for `days` days. Doesn't know about holidays."""
    ss = []
    for d in range(days):
        day = start_day + timedelta(days=d)
        if day.weekday() in daysofweek:
            start  = datetime.combine(day, start_time)
            end    = datetime.combine(day, end_time)
            length = timedelta(minutes=30)

            s = start
            while s < end:
                e = s + length
                ss.append(Interval(s, e))
                s = e
    return ss


#
# Search for schedules.
#

def schedules(meetings):
    "Generator of all possible schedules."

    if debug:
        print('Searching')
        for m in sorted(meetings, key = lambda m: len(meetings[m])):
            if len(meetings[m]) == 1:
                print('{}, scheduled!'.format(m))
            else:
                print('{}, {} slots left'.format(m, len(meetings[m])))
        print('')

    if meetings is None:
        return None

    elif all_scheduled(meetings):
        yield to_schedule(meetings)

    else:
        unscheduled = [ m for m in meetings if len(meetings[m]) > 1 ]
        for m in sorted(unscheduled, key=lambda m: len(meetings[m])):
            for s in sorted(meetings[m], key=lambda s: s.start):
                new_meetings = assign(copy_meetings(meetings), m, s)
                yield from schedules(new_meetings)


def all_scheduled(meetings):
    return all(len(slots) == 1 for slots in meetings.values())


def item(s):
    return next(iter(s))


def to_schedule(meetings):
    return sorted(((m, item(slots)) for m, slots in meetings.items()), key=lambda x: x[1].start)


def copy_meetings(meetings):
    return { m : set(s) for m, s in meetings.items() }


def assign(meetings, m, s):
    "Assign slot s to meeting m, propagating consequences."
    if debug: print('Assinging {} to {}'.format(s, m))
    return meetings if all(eliminate(meetings, m, s1) for s1 in meetings[m] - { s }) else None


def eliminate(meetings, m, s):
    "Eliminate the slot s from meeting m and propagate consequences."
    if s in meetings[m]:
        if debug: print('Eliminating {} from {}'.format(s, m))
        meetings[m].remove(s)

        if len(meetings[m]) == 0:
            return None
        elif len(meetings[m]) == 1:
            s2 = item(meetings[m])
            other_meetings = [ m2 for m2 in meetings if m2 != m ]
            if not all(eliminate(meetings, m2, s2) for m2 in other_meetings):
                return None

    return meetings


def schedule(meetings):
    "The first schedule found."
    return next(schedules(meetings))


def set_slots(m, attendees, busy, meetings):
    for a in attendees:
        to_eliminate = busy_slots(sorted(meetings[m], key = lambda x: x.start), busy[a])
        if not all(eliminate(meetings, m, s) for s in to_eliminate):
            return None
    return meetings


def make_schedule(meetings, all_slots, busy_times):
    s = { id : set(all_slots) for id in meetings }
    for id, m in meetings.items():
        s = set_slots(id, m['attendees'], busy_times, s)
    return schedule(s)


if __name__ == '__main__':

    import sys
    import fileinput

    pacific    = timezone(timedelta(hours=-7))
    start_day  = datetime.today()
    start_time = time(9, 0, tzinfo=pacific)
    end_time   = time(14, 0, tzinfo=pacific)
    days       = 30

    pat = compile(r'^(.*?): *(.*)$')

    def to_meeting(line):
        m = pat.match(line)
        return (m.group(1), split(r', *', m.group(2)))

    specs      = [ to_meeting(line[:-1]) for line in fileinput.input() ]
    meetings   = { id: { 'summary': s, 'attendees': a } for id, (s, a) in enumerate(specs) }
    emails     = set(a for x in meetings.values() for a in x['attendees'])
    busy_times = busy(emails, start_day, start_time, end_time, days)
    all_slots  = slots(start_day, start_time, end_time, days)

    sched = make_schedule(meetings, all_slots, busy_times)

    if sched is None:
        print('No way to schedule all meetings. Maybe time to become a goat farmer.')
    else:
        for id, s in sched:
            print('{:30} {}'.format(meetings[id]['summary'], s.start.strftime('%a, %B %d %I:%M %p (%Z)')))
