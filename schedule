#!/usr/bin/env python3

"Schedule a bunch of desired meetings."

from apiclient.discovery import build
from credentials import creds
from datetime import datetime, time, timedelta, timezone
from httplib2 import Http

import arrow

debug = False

class Interval():

    "Represent a time interval as start (inclusive) and end (exlcusive)."

    def __init__(self, start, end):
        self.start = start
        self.end = end

    def __eq__(self, other):
        return self.start == other.start and self.end == other.end

    def __hash__(self):
        return hash((self.start, self.end))

    def __repr__(self):
        return '{} to {}'.format(self.start.isoformat(), self.end.isoformat())

    def before(self, other):
        return self.end <= other.start

    def after(self, other):
        return self.start >= other.end

    def overlaps(self, other):
        return not (self.before(other) or self.after(other))

    def from_calendar(cal):
        return Interval(arrow.get(cal['start']), arrow.get(cal['end']))

class Meeting():

    def __init__(self, summary, minutes, invitees, attendees = None, slots = None):
        self.summary   = summary
        self.minutes   = minutes
        self.invitees  = invitees
        self.attendees = attendees
        self.slots     = slots

    def __repr__(self):
        import json
        return json.dumps({
            'summary': self.summary,
            'minutes': self.minutes,
            'invitees': list(self.invitees),
            'attendees': list(self.attendees),
            'slots': [ '{}'.format(s) for s in self.slots ]
        })

    def copy(self):
        return Meeting(self.summary, self.minutes, self.invitees, self.attendees, set(self.slots))


def busy(emails, start_day, start_time, end_time, days):
    "Map of intervals each person is busy according to their calendar."

    service = build('calendar', 'v3', http=creds.authorize(Http()))

    data = service.freebusy().query(body = {
        'timeMin': datetime.combine(start_day, start_time).isoformat(),
        'timeMax': datetime.combine(start_day + timedelta(days=days), end_time).isoformat(),
        'items': [ { 'id': e } for e in emails ],
        'timeZone': '-07:00'
    }).execute()

    busy_times = {
        name : [ Interval.from_calendar(x) for x in x['busy'] ]
        for name, x in data['calendars'].items()
    }

    groups = { g : x['calendars'] for g, x in data['groups'].items() } if 'groups' in data else {}

    return busy_times, groups

def working_slots(start_day, start_time, end_time, days=1, minutes=30, increment=15, daysofweek={0,1,2,3,4}):
    "Get all slots during working hours in a given time range."
    ss = []
    for d in range(days):
        day = start_day + timedelta(days=d)
        if day.weekday() in daysofweek:
            start  = datetime.combine(day, start_time)
            end    = datetime.combine(day, end_time)
            length = timedelta(minutes=minutes)
            incr   = timedelta(minutes=increment)

            s = start
            while s < end:
                e = s + length
                ss.append(Interval(s, e))
                s += incr
    return ss


def schedules(meetings):
    "Generator of all possible schedules."

    if meetings is None:
        return None

    elif all_scheduled(meetings):
        yield to_schedule(meetings)

    else:
        unscheduled = [ m for m in meetings if len(meetings[m].slots) > 1 ]
        for m in sorted(unscheduled, key=lambda m: len(meetings[m].slots)):
            for s in sorted(meetings[m].slots, key=lambda s: s.start):
                yield from schedules(assign(copy_meetings(meetings), m, s))


def all_scheduled(meetings):
    return all(len(meeting.slots) == 1 for meeting in meetings.values())


def to_schedule(meetings):
    return sorted(((m, item(meeting.slots)) for m, meeting in meetings.items()), key=lambda x: x[1].start)


def copy_meetings(meetings):
    return { m: meeting.copy() for m, meeting in meetings.items() }


def assign(meetings, m, s):
    "Assign slot s to meeting m, propagating consequences."
    if debug: print('Assinging {} to {}'.format(s, m))
    return meetings if eliminate(meetings, m, lambda x: x != s) else None


def eliminate(meetings, m, fn):
    "Eliminate slots from meeting m and propagate consequences."
    to_eliminate = { s for s in meetings[m].slots if fn(s) }
    if to_eliminate:
        if debug: print('Eliminating {} from {}'.format(to_eliminate, m))
        meetings[m].slots -= to_eliminate
        left = len(meetings[m].slots)

        if left == 0:
            return None
        elif left == 1:
            s = item(meetings[m].slots)
            other_meetings = overlapping_attendees(m, meetings) - { m }
            if not all(eliminate(meetings, m2, lambda x: x.overlaps(s)) for m2 in other_meetings):
                return None

    return meetings


def overlapping_attendees(m, meetings):
    attendees = meetings[m].attendees
    return { m2 for m2 in meetings if attendees & meetings[m2].attendees }


def item(s):
    return next(iter(s))


def schedule(meetings, start_day, start_time, end_time, days):
    "Find the first possible schedule for the set of meetings."
    emails = set(a for m in meetings.values() for a in m.invitees)
    busy_times, groups = busy(emails, start_day, start_time, end_time, days)

    for m, meeting in meetings.items():
        slots = set(working_slots(start_day, start_time, end_time, days, meeting.minutes))
        if not(initialize_slots(meetings, m, slots, busy_times, groups)):
            return None

    return next(schedules(meetings))


def initialize_slots(meetings, m, starting_slots, busy, groups):
    meeting           = meetings[m]
    meeting.attendees = expand(meeting.invitees, groups)
    meeting.slots     = starting_slots

    for a in meeting.attendees:
        to_eliminate = busy_slots(sorted(meeting.slots, key = lambda x: x.start), busy[a])
        if not eliminate(meetings, m, lambda x: x in to_eliminate):
            return None

    return meetings


def expand(attendees, groups):
    expansion = set()

    for a in attendees:
        if a in groups:
            expansion |= set(groups[a])
        else:
            expansion.add(a)

    return expansion


def busy_slots(slots, busy):
    "Find intervals in slots that overlap busy intervals."

    def walk(slots, busy):
        while slots and busy:
            s = slots[0]
            b = busy[0]
            if s.before(b):
                slots.pop(0)
            elif s.after(b):
                busy.pop(0)
            else:
                yield slots.pop(0)

    return list(walk(slots[:], busy[:]))


if __name__ == '__main__':

    import fileinput
    import re
    import sys

    pacific    = timezone(timedelta(hours=-7))
    start_day  = datetime.today()
    start_time = time(9, 0, tzinfo=pacific)
    end_time   = time(14, 0, tzinfo=pacific)
    days       = 60

    pat = re.compile(r'^\[(\d+)\] *(.*?): *(.*)$')

    def to_meeting(line):
        m = pat.match(line)
        return Meeting(m.group(2), int(m.group(1)), frozenset(re.split(r', *', m.group(3))))

    meetings = { id: to_meeting(line[:-1]) for id, line in enumerate(fileinput.input()) }

    sched = schedule(meetings, start_day, start_time, end_time, days)

    if sched is None:
        print('No way to schedule all meetings. Maybe time to become a goat farmer.')
    else:
        for id, s in sched:
            print('{:30} {} to {}'.format(
                meetings[id].summary,
                s.start.strftime('%a, %b %d %I:%M %p'),
                s.end.strftime('%I:%M %p (%Z)')))
